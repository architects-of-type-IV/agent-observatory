{"id":"1","status":"completed","subject":"Implement HeartbeatManager GenServer (Section 4.1)","description":"This section creates the `Observatory.Gateway.HeartbeatManager` GenServer, defines its public API (`record_heartbeat/2`), wires the 30-second self-check loop with a 90-second eviction threshold, creates the `gateway_heartbeats` SQLite table migration, and implements the `POST /gateway/heartbeat` HTTP endpoint. By the end of this section, agents can ping the gateway to register their liveness and stale agents are automatically removed from both the in-memory state map and the live Capability Map Subtasks: - [ ] 4.1.1.1 Create `lib/observatory/gateway/heartbeat_manager.ex` with `use GenServer`, declare `@eviction_threshold_seconds 90` and `@check_interval_ms 30_000`, add `def start_link/1` that registers the process as `__MODULE__`, and implement `init/1` that calls `:timer.send_interval(@check_interval_ms, :check_heartbeats)` and returns `{:ok, %{}}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.1.1.2 Implement `def record_heartbeat(agent_id, cluster_id)` as `GenServer.call(__MODULE__, {:heartbeat, agent_id, cluster_id})` and the corresponding `handle_call/3` that inserts or replaces `agent_id => %{last_seen: DateTime.utc_now(), cluster_id: cluster_id}` in the state map and returns `{:reply, :ok, updated_state}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.1.1.3 Implement `handle_info(:check_heartbeats, state)` that calls `DateTime.utc_now()`, iterates every entry in state via `Enum.filter/2`, evicts agents where `DateTime.diff(now, last_seen, :second) > @eviction_threshold_seconds`, calls `Observatory.Gateway.CapabilityMap.remove_agent(agent_id)` for each evicted entry, logs each eviction at `:info` level with `agent_id` and `last_seen` fields, and returns `{:noreply, Map.drop(state, evicted_agent_ids)}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.1.1.4 Add `Observatory.Gateway.HeartbeatManager` to the application supervisor in `lib/observatory/application.ex` under the Gateway children group `done_when: \"mix compile --warnings-as-errors\"` - [","goal":"Section 4.1 compiles from scratch matching its FRD exactly","acceptance_criteria":["mix compile --warnings-as-errors","mix ecto.migrate && mix compile --warnings-as-errors","mix test test/observatory/gateway/heartbeat_manager_test.exs","mix test test/observatory_web/controllers/heartbeat_controller_test.exs"],"priority":"high","blocked_by":[],"files":["lib/observatory_web/controllers/heartbeat_controller.ex","lib/observatory_web/router.ex","lib/observatory/application.ex","lib/observatory/gateway/heartbeat_manager.ex","lib/observatory/gateway/heartbeat_record.ex","priv/repo/migrations/","test/observatory_web/controllers/heartbeat_controller_test.exs","test/observatory/gateway/heartbeat_manager_test.exs"],"done_when":"mix compile --warnings-as-errors && mix test test/observatory_web/controllers/heartbeat_controller_test.exs test/observatory/gateway/heartbeat_manager_test.exs","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T15:45:34Z","tags":["phase-4","heartbeatmanager-genserver","section-4.1"],"roadmap_ref":"4.1","notes":""}
{"id":"2","status":"completed","subject":"Implement CronScheduler & DB Schema (Section 4.2)","description":"This section implements the `Observatory.Gateway.CronScheduler` GenServer with its `schedule_once/3` public API, creates the `cron_jobs` SQLite table migration, implements startup recovery for unfinished jobs, and wires the SchemaInterceptor extension that translates `schedule_reminder` tool calls into `CronScheduler.schedule_once/3` invocations. By the end of this section, agents can request timed reminders via DecisionLog tool calls, and the scheduler survives process crashes without silently Subtasks: - [ ] 4.2.1.1 Create `lib/observatory/gateway/cron_scheduler.ex` with `use GenServer`, implement `start_link/1` that registers as `__MODULE__`, and implement `init/1` that queries all `cron_jobs` rows from the Repo, schedules timers for each using `Process.send_after(self(), {:fire_job, row.id, row.agent_id, row.payload}, max(delay_until_fire, 0))` where `delay_until_fire` is computed as `DateTime.diff(row.next_fire_at, DateTime.utc_now(), :millisecond)`, and returns `{:ok, %{jobs: %{}}}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.2.1.2 Implement `def schedule_once(agent_id, delay_ms, payload)` as a `GenServer.call` that returns `{:error, :invalid_delay}` when `delay_ms` is not a positive integer, otherwise inserts a `CronJob` Ecto record with `is_one_time: true`, `next_fire_at: DateTime.add(DateTime.utc_now(), delay_ms, :millisecond)`, and `payload: Jason.encode!(payload)`, then calls `Process.send_after/3` with the timer, and returns `:ok` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.2.1.3 Implement `handle_info({:fire_job, job_id, agent_id, payload_json}, state)` that decodes `payload_json` via `Jason.decode!/1`, calls `Phoenix.PubSub.broadcast(Observatory.PubSub, \"agent:#{agent_id}:scheduled\", decoded_payload)`, queries the `cron_jobs` row by `job_id`, and if `is_one_time: true` deletes the row from the Repo; for recurring jobs updates `next_fire_at` and re-schedules the timer; returns `{:noreply, state}` `done_when: \"mix compile --warnings-as-erro","goal":"Section 4.2 compiles from scratch matching its FRD exactly","acceptance_criteria":["mix compile --warnings-as-errors","mix ecto.migrate && mix compile --warnings-as-errors","mix test test/observatory/gateway/cron_scheduler_test.exs"],"priority":"high","blocked_by":["1"],"files":["lib/observatory/application.ex","lib/observatory/gateway/cron_job.ex","lib/observatory/gateway/cron_scheduler.ex","lib/observatory/gateway/schema_interceptor.ex","priv/repo/migrations/","test/observatory/gateway/cron_scheduler_test.exs"],"done_when":"mix compile --warnings-as-errors && mix test test/observatory/gateway/cron_scheduler_test.exs","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T15:50:29Z","tags":["phase-4","cronscheduler-db-schema","section-4.2"],"roadmap_ref":"4.2","notes":""}
{"id":"3","status":"completed","subject":"Implement WebhookRouter Retry & DLQ (Section 4.3)","description":"This section creates the `Observatory.Gateway.WebhookRouter` GenServer that manages durable webhook delivery with exponential-backoff retry semantics, implements HMAC-SHA256 signature computation for outbound webhooks and timing-safe validation for inbound webhooks, creates the `webhook_deliveries` and `webhook_configs` SQLite migrations, implements startup re-queuing of undelivered entries, enforces the five-per-poll thundering-herd cap, and exposes `POST /gateway/webhooks/:webhook_id` for inbo Subtasks: - [ ] 4.3.1.1 Create `lib/observatory/gateway/webhook_router.ex` with `use GenServer`, declare `@retry_schedule_seconds [30, 120, 600, 3600, 21600]` and `@poll_interval_ms 5_000`, implement `start_link/1` registered as `__MODULE__`, implement `init/1` that calls startup re-queuing (calls private `requeue_undelivered/0`) and schedules the first poll via `Process.send_after(self(), :poll, @poll_interval_ms)`, returns `{:ok, %{}}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.3.1.2 Implement `handle_info(:poll, state)` that queries `Repo.all(from d in WebhookDelivery, where: d.status in [\"pending\", \"failed\"] and d.next_retry_at <= ^DateTime.utc_now(), limit: 5)`, calls `attempt_delivery/1` for each, re-schedules the next poll via `Process.send_after(self(), :poll, @poll_interval_ms)`, returns `{:noreply, state}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.3.1.3 Implement private `attempt_delivery/1` that issues an HTTP POST to `delivery.target_url` with body `delivery.payload` and header `X-Observatory-Signature: sha256=#{delivery.signature}` using `Req.post/2` or `:httpc.request/4`; on HTTP 2xx calls `mark_delivered/1` to set `status: \"delivered\"`; on failure calls `schedule_retry/1` that increments `attempt_count`, looks up the delay via `Enum.at(@retry_schedule_seconds, delivery.attempt_count)`, sets `next_retry_at: DateTime.add(DateTime.utc_now(), delay, :second)` and `status: \"failed\"`, or if `attempt_count >= 5` sets `status: \"dead\"` and broadcasts `%","goal":"Section 4.3 compiles from scratch matching its FRD exactly","acceptance_criteria":["mix compile --warnings-as-errors","mix ecto.migrate && mix compile --warnings-as-errors","mix test test/observatory/gateway/webhook_deliveries_test.exs","mix test test/observatory/gateway/webhook_router_test.exs","mix test test/observatory_web/controllers/webhook_controller_test.exs"],"priority":"high","blocked_by":["1","2"],"files":["lib/observatory_web/controllers/webhook_controller.ex","lib/observatory_web/router.ex","lib/observatory/application.ex","lib/observatory/gateway/webhook_delivery.ex","lib/observatory/gateway/webhook_router.ex","priv/repo/migrations/","test/observatory_web/controllers/webhook_controller_test.exs","test/observatory/gateway/webhook_deliveries_test.exs","test/observatory/gateway/webhook_router_test.exs"],"done_when":"mix compile --warnings-as-errors && mix test test/observatory_web/controllers/webhook_controller_test.exs test/observatory/gateway/webhook_deliveries_test.exs test/observatory/gateway/webhook_router_test.exs","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T15:54:14Z","tags":["phase-4","webhookrouter-retry-dlq","section-4.3"],"roadmap_ref":"4.3","notes":""}
{"id":"4","status":"completed","subject":"Implement HITLRelay State Machine (Section 4.4)","description":"This section creates the `Observatory.Gateway.HITLRelay` GenServer that manages the per-session `Normal` / `Paused` state machine, owns the `:hitl_buffer` ETS table, buffers incoming DecisionLog messages while a session is paused, supports in-buffer rewriting by `meta.trace_id`, and flushes the buffer in arrival order on unpause. It also defines the four command types and their required field contracts. By the end of this section, the HITL pause mechanism is fully functional at the GenServer lay Subtasks: - [ ] 4.4.1.1 Create `lib/observatory/gateway/hitl_relay.ex` with `use GenServer`, implement `start_link/1` registered as `__MODULE__`, implement `init/1` that creates the ETS table via `:ets.new(:hitl_buffer, [:ordered_set, :public, :named_table])` and returns `{:ok, %{sessions: %{}}}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.4.1.2 Implement `def pause(session_id, agent_id, operator_id, reason)` as `GenServer.call(__MODULE__, {:pause, session_id, agent_id, operator_id, reason})` and the corresponding `handle_call/3` that (a) checks whether `session_id` is already `:paused` in state and returns `{:reply, {:ok, :already_paused}, state}` if so; (b) otherwise transitions the session to `:paused` in state, broadcasts `%HITLGateOpenEvent{session_id: session_id, agent_id: agent_id, operator_id: operator_id, reason: reason, timestamp: DateTime.utc_now()}` on `\"session:hitl:#{session_id}\"` via `Phoenix.PubSub.broadcast/3`, and returns `{:reply, :ok, updated_state}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.4.1.3 Implement `def unpause(session_id, agent_id, operator_id)` as `GenServer.call(__MODULE__, {:unpause, session_id, agent_id, operator_id})` and the corresponding `handle_call/3` that (a) flushes the ETS buffer for key `{session_id, agent_id}` by looking up the ordered list, broadcasting each `%DecisionLog{}` sequentially on the standard DecisionLog PubSub topic via `Phoenix.PubSub.broadcast/3`, deleting the ETS entry via `:ets.delete/2` after the fl","goal":"Section 4.4 compiles from scratch matching its FRD exactly","acceptance_criteria":["mix compile --warnings-as-errors","mix test test/observatory/gateway/hitl_relay_test.exs"],"priority":"high","blocked_by":["3"],"files":["lib/observatory/application.ex","lib/observatory/gateway/hitl_events.ex","lib/observatory/gateway/hitl_relay.ex","test/observatory/gateway/hitl_relay_test.exs"],"done_when":"mix compile --warnings-as-errors && mix test test/observatory/gateway/hitl_relay_test.exs","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T15:59:58Z","tags":["phase-4","hitlrelay-state-machine","section-4.4"],"roadmap_ref":"4.4","notes":""}
{"id":"5","status":"completed","subject":"Implement HITL HTTP Endpoints & Auth (Section 4.5)","description":"This section exposes the four HITL HTTP endpoints under `/gateway/sessions/:session_id/`, implements the `Observatory.Plugs.OperatorAuth` plug that enforces the `X-Observatory-Operator-Id` header, creates the `HITLInterventionEvent` Ash resource with its SQLite data layer, and wires the audit trail creation into each successfully processed controller action. By the end of this section, operators can issue HITL commands via HTTP, all requests are authenticated, and every successful command leaves Subtasks: - [ ] 4.5.1.1 Create `lib/observatory/plugs/operator_auth.ex` under module `Observatory.Plugs.OperatorAuth` with `@behaviour Plug`, implement `init/1` that returns opts unchanged, implement `call/2` that reads `conn |> get_req_header(\"x-observatory-operator-id\") |> List.first()`, applies `String.trim/1`, halts with `conn |> put_status(401) |> json(%{status: \"error\", reason: \"missing_operator_id\"}) |> halt()` if the trimmed value is empty or nil, otherwise assigns the value to `conn.assigns[:operator_id]` via `assign(conn, :operator_id, trimmed_value)` and returns `conn` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.5.2.1 Create `lib/observatory_web/controllers/hitl_controller.ex` under module `ObservatoryWeb.HITLController`; implement `def pause(conn, params)` that validates `params` contains `\"agent_id\"`, `\"operator_id\"`, and `\"reason\"` (all non-empty strings), returns HTTP 422 `{\"status\": \"error\", \"reason\": \"missing_required_field: #{field}\"}` for the first missing field, and on success calls `HITLRelay.pause(session_id, agent_id, operator_id, reason)` where `session_id` is `conn.path_params[\"session_id\"]` and returns `json(conn, %{status: \"ok\"})` on `:ok` or `json(conn, %{status: \"ok\", note: \"already_paused\"})` on `{:ok, :already_paused}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.5.2.2 In `ObservatoryWeb.HITLController`, implement `def unpause(conn, params)` validating `\"agent_id\"` and `\"operator_id\"`, calling `HITLRelay.unpause/3`; implement `def r","goal":"Section 4.5 compiles from scratch matching its FRD exactly","acceptance_criteria":["mix ash.migrate && mix compile --warnings-as-errors","mix compile --warnings-as-errors","mix test test/observatory_web/controllers/hitl_controller_test.exs"],"priority":"high","blocked_by":["3"],"files":["lib/observatory_web/controllers/hitl_controller.ex","lib/observatory_web/router.ex","lib/observatory/gateway/hitl_intervention_event.ex","lib/observatory/plugs/operator_auth.ex","test/observatory_web/controllers/hitl_controller_test.exs"],"done_when":"mix compile --warnings-as-errors && mix test test/observatory_web/controllers/hitl_controller_test.exs","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T16:00:04Z","tags":["phase-4","hitl-http-endpoints-auth","section-4.5"],"roadmap_ref":"4.5","notes":""}
{"id":"6","status":"completed","subject":"Implement Auto-Pause & Operator Actions (Section 4.6)","description":"This section wires the `SchemaInterceptor` to auto-pause sessions when `control.hitl_required == true` is detected on an incoming DecisionLog, implements the three operator approval actions (Approve, Rewrite, Reject) at the LiveView layer in the Session Drill-down, and defines the diamond DAG node rendering for `HITLInterventionEvent` records in the causal DAG timeline. By the end of this section, the full HITL flow — from agent-flagged message to operator approval and resumption — is functi Subtasks: - [ ] 4.6.1.1 In `lib/observatory/gateway/schema_interceptor.ex`, add a private function `maybe_auto_pause/1` that receives a `%DecisionLog{}` struct and checks `log.control && log.control.hitl_required == true`; when true, calls `HITLRelay.pause(log.meta.cluster_id, log.identity.agent_id, \"system\", \"hitl_required_flag\")`, then calls `HITLRelay.buffer_message(session_id, log.identity.agent_id, log)` to place the triggering DecisionLog into the buffer, and returns `{:paused, log}`; when false or nil, returns `{:normal, log}` `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.6.1.2 In the SchemaInterceptor's post-validation dispatch pipeline, call `maybe_auto_pause(decision_log)` first; on `{:paused, _log}`, skip the downstream PubSub broadcast for the DecisionLog (it is in the buffer); on `{:normal, log}`, proceed with the existing broadcast path including the `maybe_schedule_reminder/1` call from section 4.2.3 `done_when: \"mix compile --warnings-as-errors\"` - [ ] 4.6.1.3 Write a test in `test/observatory/gateway/schema_interceptor_test.exs` (or create this file if absent) verifying that a validated DecisionLog with `control.hitl_required: true` triggers a `HITLGateOpenEvent` broadcast on `\"session:hitl:#{session_id}\"` and is NOT broadcast on the standard DecisionLog PubSub topic until `HITLRelay.unpause/3` is called `done_when: \"mix test test/observatory/gateway/schema_interceptor_test.exs\"` - [ ] 4.6.2.1 Create `lib/observatory_web/live/session_drilldown_live.ex` under ","goal":"Section 4.6 compiles from scratch matching its FRD exactly","acceptance_criteria":["mix compile --warnings-as-errors","mix test test/observatory/gateway/hitl_relay_test.exs","mix test test/observatory/gateway/schema_interceptor_test.exs","mix test test/observatory_web/live/session_drilldown_live_test.exs"],"priority":"high","blocked_by":["2","4"],"files":["lib/observatory_web/live/session_drilldown_live.ex","lib/observatory/gateway/schema_interceptor.ex","test/observatory_web/live/session_drilldown_live_test.exs","test/observatory/gateway/hitl_relay_test.exs","test/observatory/gateway/schema_interceptor_test.exs"],"done_when":"mix compile --warnings-as-errors && mix test test/observatory_web/live/session_drilldown_live_test.exs test/observatory/gateway/hitl_relay_test.exs test/observatory/gateway/schema_interceptor_test.exs","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T16:05:40Z","tags":["phase-4","auto-pause-operator-actions","section-4.6"],"roadmap_ref":"4.6","notes":""}
{"id":"7","status":"completed","subject":"Generate migrations and run full test suite (Phase 4 final)","description":"Final integration task for Phase 4. Generate any pending migrations, apply them, and run the complete test suite with zero failures and zero warnings. Adapt commands to the project build system.","goal":"All Phase 4 changes integrated, full test suite green","acceptance_criteria":["All pending migrations/schema changes applied","Full test suite passes with 0 failures","Build passes with zero warnings"],"priority":"critical","blocked_by":["1","2","3","4","5","6"],"files":[],"done_when":"mix compile --warnings-as-errors && mix test","owner":"lead","created":"2026-02-22T15:40:51Z","updated":"2026-02-22T16:14:32Z","tags":["phase-4","migration","final"],"roadmap_ref":"4.final","notes":"Blocks on ALL other tasks. Run all schema changes and tests in one final pass."}
