---
id: UC-0273
title: Unpause Session and Flush Buffered DecisionLogs in Order
status: draft
parent_fr: FR-11.3
adrs: [ADR-021]
---

# UC-0273: Unpause Session and Flush Buffered DecisionLogs in Order

## Intent
When an operator issues the `hitl_unpause` command, the HITLRelay transitions the session from `Paused` to `Normal`, broadcasts each buffered DecisionLog sequentially on the standard DecisionLog PubSub topic in their original arrival order (with any rewrites applied), clears the ETS buffer entry, and emits a `HITLGateCloseEvent` so that the LiveView can hide the approval gate.

## Primary Actor
HITLRelay

## Supporting Actors
- `:hitl_buffer` ETS table
- PubSub topic (standard DecisionLog topic per session)
- PubSub topic `"session:hitl:#{session_id}"`
- `HITLInterventionEvent` Ash resource

## Preconditions
- The HITLRelay GenServer is running.
- Session `session_id` is in `Paused` state.
- The `:hitl_buffer` ETS table has the key `{session_id, agent_id}` (possibly mapping to an empty list if no logs arrived while paused).
- The request includes a valid `X-Observatory-Operator-Id` header.

## Trigger
An operator sends `POST /gateway/sessions/:session_id/unpause` with a valid body and operator header.

## Main Success Flow
1. The operator authentication plug validates `X-Observatory-Operator-Id` and sets `conn.assigns[:operator_id]`.
2. The controller calls `HITLRelay.unpause(session_id, agent_id, operator_id)`.
3. HITLRelay confirms the session is in `Paused` state.
4. HITLRelay fetches the buffer list from ETS at `{session_id, agent_id}`.
5. For each entry in the list (in order): `Phoenix.PubSub.broadcast(Observatory.PubSub, "session:#{session_id}:decisions", entry)`. Each broadcast completes before the next is initiated.
6. After the full list is forwarded, HITLRelay deletes the ETS entry for `{session_id, agent_id}`.
7. HITLRelay transitions the session to `Normal` state.
8. HITLRelay broadcasts `%HITLGateCloseEvent{session_id: session_id, agent_id: agent_id, operator_id: operator_id, timestamp: DateTime.utc_now()}` on `"session:hitl:#{session_id}"`.
9. A `HITLInterventionEvent` row is created with `command_type: :hitl_unpause`.
10. The controller returns HTTP 200 `{"status": "ok"}`.

## Alternate Flows
### A1: Empty Buffer on Unpause
Condition: No DecisionLogs arrived while the session was paused; the ETS list is empty.
Steps:
1. HITLRelay fetches the buffer and finds `[]`.
2. No broadcast is made (empty iteration).
3. The ETS entry is deleted.
4. The session transitions to `Normal`.
5. `HITLGateCloseEvent` is broadcast.
6. No exception is raised.

## Failure Flows
### F1: GenServer Crash Mid-Flush
Condition: The HITLRelay GenServer crashes after broadcasting some entries but before completing the flush.
Steps:
1. The ETS table (owned by the crashed process) is destroyed, and all remaining buffered entries are lost.
2. The crash is logged at `:error` level with `session_id` for operator investigation.
3. The OTP supervisor restarts the HITLRelay; the session state is reset to `Normal` (no recovery of lost buffer).
Result: Partial flush with message loss. Phase 1 does not provide crash-safe flush durability. Operators must be alerted via the `:error` log.

## Gherkin Scenarios

### S1: Unpause flushes three buffered messages in order
```gherkin
Scenario: Unpause broadcasts buffered DecisionLogs in arrival order
  Given session "sess-abc" is in Paused state
  And the :hitl_buffer ETS entry for {"sess-abc","agent-1"} is [T1, T2_rewritten, T3]
  When a POST to /gateway/sessions/sess-abc/unpause is made with a valid body and operator header
  Then the response status is 200
  And T1 is broadcast on the standard DecisionLog PubSub topic for "sess-abc" first
  And T2_rewritten is broadcast second
  And T3 is broadcast third
  And the :hitl_buffer ETS entry for {"sess-abc","agent-1"} is deleted
  And session "sess-abc" transitions to Normal state
  And a HITLGateCloseEvent is broadcast on "session:hitl:sess-abc"
```

### S2: Unpause with empty buffer is a no-op flush
```gherkin
Scenario: Unpause with no buffered messages transitions state without error
  Given session "sess-abc" is in Paused state
  And the :hitl_buffer ETS entry for {"sess-abc","agent-1"} is []
  When a POST to /gateway/sessions/sess-abc/unpause is made
  Then the response status is 200
  And no DecisionLog broadcast occurs
  And session "sess-abc" transitions to Normal state
  And a HITLGateCloseEvent is broadcast on "session:hitl:sess-abc"
```

## Acceptance Criteria
- [ ] `mix test test/observatory/gateway/hitl_relay_test.exs` passes a test that `hitl_unpause` with three buffered entries broadcasts them in order on the session DecisionLog topic, deletes the ETS entry, and transitions the session to `Normal`.
- [ ] `mix test test/observatory/gateway/hitl_relay_test.exs` passes a test that `hitl_unpause` with an empty ETS buffer transitions to `Normal` and broadcasts `HITLGateCloseEvent` without raising.
- [ ] `mix compile --warnings-as-errors` passes.

## Data
**Inputs:** `session_id`, `agent_id`, `operator_id`; ETS buffer list for `{session_id, agent_id}`
**Outputs:** Sequential PubSub broadcasts of buffered DecisionLogs; `HITLGateCloseEvent`; HTTP 200
**State changes:** HITLRelay session state: `Paused` -> `Normal`; ETS `{session_id, agent_id}` entry deleted; `HITLInterventionEvent` row created.

## Traceability
- Parent FR: FR-11.3
- ADR: [ADR-021](../../decisions/ADR-021-hitl-intervention-api.md)
