---
id: UC-0304
title: Delegate View Rendering to Dedicated Component Module
status: draft
parent_fr: FR-12.5
adrs: [ADR-022]
---

# UC-0304: Delegate View Rendering to Dedicated Component Module

## Intent
Each of the six `view_mode` atoms must be rendered by exactly one dedicated component module at a fixed, known module path. The LiveView `render/1` function pattern-matches on `view_mode` and dispatches to the corresponding component module's primary function. No view may be rendered by a module whose name or namespace does not match the canonical mapping. This UC validates that the dispatch chain is correctly wired and that a missing or misnamed module is caught at compile time rather than at runtime.

## Primary Actor
DashboardLive

## Supporting Actors
- FleetCommandComponents (`lib/observatory_web/components/fleet_command_components.ex`)
- SessionClusterComponents (`lib/observatory_web/components/session_cluster_components.ex`)
- RegistryComponents (`lib/observatory_web/components/registry_components.ex`)
- SchedulerComponents (`lib/observatory_web/components/scheduler_components.ex`)
- ForensicComponents (`lib/observatory_web/components/forensic_components.ex`)
- GodModeComponents (`lib/observatory_web/components/god_mode_components.ex`)
- Phoenix.Component macro system

## Preconditions
- All six component modules exist at their canonical file paths.
- Each module exposes a public function component (`def fleet_command_view(assigns)`, `def session_cluster_view(assigns)`, etc.) that accepts the full socket assigns map.
- DashboardLive is mounted with a valid `view_mode` atom.

## Trigger
The LiveView `render/1` function is invoked with a socket assigns map containing a `view_mode` atom.

## Main Success Flow
1. `DashboardLive.render/1` receives assigns with `view_mode: :registry`.
2. The render function pattern-matches on `:registry` and calls `RegistryComponents.registry_view(assigns)`.
3. `RegistryComponents` is defined at `lib/observatory_web/components/registry_components.ex`.
4. The function renders the Registry view primary layout without raising `UndefinedFunctionError`.
5. The rendered HTML is returned to the LiveView diff engine.

## Alternate Flows
### A1: view_mode is :fleet_command
Condition: `view_mode: :fleet_command`.
Steps:
1. `render/1` calls `FleetCommandComponents.fleet_command_view(assigns)`.
2. Module at `lib/observatory_web/components/fleet_command_components.ex` renders successfully.

### A2: view_mode is :session_cluster
Condition: `view_mode: :session_cluster`.
Steps:
1. `render/1` calls `SessionClusterComponents.session_cluster_view(assigns)`.
2. Module renders successfully.

### A3: view_mode is :scheduler
Condition: `view_mode: :scheduler`.
Steps:
1. `render/1` calls `SchedulerComponents.scheduler_view(assigns)`.
2. Module renders successfully.

### A4: view_mode is :forensic
Condition: `view_mode: :forensic`.
Steps:
1. `render/1` calls `ForensicComponents.forensic_view(assigns)`.
2. Module renders successfully.

### A5: view_mode is :god_mode
Condition: `view_mode: :god_mode`.
Steps:
1. `render/1` calls `GodModeComponents.god_mode_view(assigns)`.
2. Module renders successfully.

## Failure Flows
### F1: Component module defined in wrong namespace
Condition: A developer creates `ObservatoryWeb.RegistryView` instead of `ObservatoryWeb.Components.RegistryComponents`. The `render/1` function still calls `RegistryComponents.registry_view/1`.
Steps:
1. The compiler resolves `RegistryComponents` to `ObservatoryWeb.Components.RegistryComponents`.
2. If that module does not exist, the compiler raises `UndefinedFunctionError` or `CompileError` at the `render/1` call site.
Result: Compilation fails; the mismatch is caught before runtime; the developer is directed to the correct namespace.

## Gherkin Scenarios

### S1: render/1 dispatches to RegistryComponents for :registry view_mode
```gherkin
Scenario: Correct component module is called for :registry view
  Given all six component modules exist at their canonical file paths
  And the socket assign "view_mode" equals ":registry"
  When DashboardLive render/1 is invoked
  Then the function "RegistryComponents.registry_view/1" is called with the socket assigns
  And the rendered HTML does not contain an error page or UndefinedFunctionError
```

### S2: All six view_mode atoms dispatch to distinct modules without error
```gherkin
Scenario: Each view_mode atom dispatches to its dedicated component module
  Given all six component modules exist at their canonical paths
  When DashboardLive render/1 is invoked for each of the six view_mode atoms
  Then each invocation calls a distinct component module function
  And no invocation raises UndefinedFunctionError or FunctionClauseError
```

## Acceptance Criteria
- [ ] `mix test test/observatory_web/live/dashboard_live_test.exs` passes tests that mount DashboardLive with each of the six `view_mode` atoms and assert the rendered HTML contains the expected view container element for each.
- [ ] `mix test test/observatory_web/live/dashboard_live_test.exs` passes a test that mounts DashboardLive with `view_mode: :registry` and asserts the rendered HTML does not contain an error page or UndefinedFunctionError and that the registry view container element is present.
- [ ] `mix compile --warnings-as-errors` passes with all six component module files present at their canonical paths.

## Data
**Inputs:** `view_mode` socket assign (one of six valid atoms), full socket assigns map
**Outputs:** Rendered HTML from the matching component module
**State changes:** Read-only â€” render/1 does not modify socket assigns.

## Traceability
- Parent FR: FR-12.5
- ADR: [ADR-022](../../decisions/ADR-022-six-view-ui-architecture.md)
