---
id: UC-0275
title: Write HITLInterventionEvent Audit Row for Every Processed Command
status: draft
parent_fr: FR-11.7
adrs: [ADR-021]
---

# UC-0275: Write HITLInterventionEvent Audit Row for Every Processed Command

## Intent
Every successfully processed HITL command creates a `HITLInterventionEvent` Ash resource row capturing the operator identity, command type, session context, and before/after state hashes of the affected DecisionLog. Commands that do not target a specific message (such as `hitl_pause` and `hitl_unpause`) record `nil` for the hash fields rather than crashing on a nil hash computation.

## Primary Actor
HITLRelay

## Supporting Actors
- `HITLInterventionEvent` Ash resource at `lib/observatory/gateway/hitl_intervention_event.ex`
- SQLite data layer (Ash resource backing store)
- `:crypto.hash/2` (SHA-256 of DecisionLog struct)

## Preconditions
- The `HITLInterventionEvent` Ash resource is defined with the required fields: `id`, `session_id`, `agent_id`, `operator_id`, `command_type`, `before_state`, `after_state`, `timestamp`, `reversed_at`.
- The HITL command has passed all field validation and been processed by HITLRelay without error.

## Trigger
HITLRelay successfully processes any of the four command types (`hitl_pause`, `hitl_rewrite`, `hitl_inject`, `hitl_unpause`).

## Main Success Flow
1. HITLRelay processes the HITL command and applies the state change.
2. For `hitl_rewrite`: HITLRelay computes `before_state = Base.encode16(:crypto.hash(:sha256, :erlang.term_to_binary(original_log)))` and `after_state = Base.encode16(:crypto.hash(:sha256, :erlang.term_to_binary(rewritten_log)))`.
3. For `hitl_pause` and `hitl_unpause`: `before_state` and `after_state` are `nil`.
4. For `hitl_inject`: `before_state` is `nil`; `after_state` is the SHA-256 of the synthetic DecisionLog struct.
5. HITLRelay calls the Ash resource create action with all required fields.
6. The Ash resource persists the row to the SQLite data layer.
7. The row is immediately queryable for audit purposes.

## Alternate Flows
### A1: Subsequent Rewrite Supersedes a Prior Intervention
Condition: A second `hitl_rewrite` is issued at the same pause window after a first rewrite.
Steps:
1. The second rewrite is processed and a new `HITLInterventionEvent` row is created.
2. The original rewrite row's `reversed_at` field is set to the current timestamp to indicate supersession.
3. Both rows remain in the database for audit completeness.

## Failure Flows
### F1: Ash Resource Create Fails
Condition: The Ash resource create action raises an error (e.g., database constraint violation or connection issue).
Steps:
1. The error is caught and logged at `:error` level with `session_id` and `command_type`.
2. The HITL command's state change has already been applied to HITLRelay; the audit failure does not roll back the state change.
3. The controller still returns HTTP 200 to the operator (the audit row failure is not surfaced as a request error in Phase 1).
Result: A gap in the audit trail exists; the operator is notified via the `:error` log.

## Gherkin Scenarios

### S1: hitl_rewrite creates audit row with before and after SHA-256 hashes
```gherkin
Scenario: hitl_rewrite creates HITLInterventionEvent with before_state and after_state hashes
  Given session "sess-abc" is Paused with buffered entry T2 at trace_id "trace-T2"
  And operator "operator-xander" issues a hitl_rewrite targeting "trace-T2" with new_content "revised reasoning"
  When HITLRelay processes the rewrite
  Then a HITLInterventionEvent row is created with:
    | command_type | :hitl_rewrite        |
    | operator_id  | operator-xander      |
    | session_id   | sess-abc             |
    | before_state | sha256(T2_original)  |
    | after_state  | sha256(T2_rewritten) |
    | reversed_at  | nil                  |
```

### S2: hitl_pause creates audit row with nil state hashes
```gherkin
Scenario: hitl_pause creates HITLInterventionEvent with nil before_state and after_state
  Given session "sess-abc" is in Normal state
  When operator "operator-xander" issues a hitl_pause command
  Then a HITLInterventionEvent row is created with:
    | command_type | :hitl_pause |
    | before_state | nil         |
    | after_state  | nil         |
  And no exception is raised on nil hash computation
```

## Acceptance Criteria
- [ ] `mix test test/observatory/gateway/hitl_relay_test.exs` passes a test that a processed `hitl_rewrite` command creates a `HITLInterventionEvent` row with non-nil `before_state` and `after_state` SHA-256 hex strings.
- [ ] `mix test test/observatory/gateway/hitl_relay_test.exs` passes a test that a processed `hitl_pause` command creates a `HITLInterventionEvent` row with `before_state: nil` and `after_state: nil` without raising.
- [ ] `mix compile --warnings-as-errors` passes.

## Data
**Inputs:** Processed HITL command (type, session_id, agent_id, operator_id, timestamp); affected DecisionLog structs (for rewrite/inject)
**Outputs:** `HITLInterventionEvent` Ash resource row in SQLite
**State changes:** One `HITLInterventionEvent` row created per successfully processed command; `reversed_at` updated on supersession.

## Traceability
- Parent FR: FR-11.7
- ADR: [ADR-021](../../decisions/ADR-021-hitl-intervention-api.md)
