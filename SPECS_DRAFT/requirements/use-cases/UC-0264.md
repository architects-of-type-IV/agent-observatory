---
id: UC-0264
title: Schedule One-Time Agent Reminder via CronScheduler
status: draft
parent_fr: FR-10.5
adrs: [ADR-019]
---

# UC-0264: Schedule One-Time Agent Reminder via CronScheduler

## Intent
An agent or internal system component requests a one-time timed reminder by calling `CronScheduler.schedule_once/3`. The CronScheduler registers a timer and, when it fires, broadcasts the payload to the agent's dedicated PubSub topic, enabling the agent to receive asynchronous wake-up signals without polling.

## Primary Actor
CronScheduler

## Supporting Actors
- `Observatory.Gateway.CronScheduler` GenServer (named process)
- `cron_jobs` SQLite table
- PubSub topic `"agent:#{agent_id}:scheduled"`

## Preconditions
- The CronScheduler GenServer is running and registered as `Observatory.Gateway.CronScheduler`.
- The `cron_jobs` table exists and the migration has been applied.
- `delay_ms` is a positive integer.

## Trigger
A caller invokes `CronScheduler.schedule_once(agent_id, delay_ms, payload)` with valid arguments.

## Main Success Flow
1. The CronScheduler receives the `schedule_once/3` call.
2. It validates that `delay_ms > 0`.
3. It computes `next_fire_at = DateTime.add(DateTime.utc_now(), delay_ms, :millisecond)`.
4. It writes a row to `cron_jobs` with `is_one_time: true`, `agent_id`, `next_fire_at`, and `payload` JSON-encoded.
5. It registers an internal timer via `Process.send_after(self(), {:fire_job, job_id}, delay_ms)`.
6. It returns `:ok` to the caller.
7. After `delay_ms` milliseconds, the timer fires and the CronScheduler receives `{:fire_job, job_id}` in `handle_info/2`.
8. The scheduler broadcasts `payload` on `Phoenix.PubSub.broadcast(Observatory.PubSub, "agent:#{agent_id}:scheduled", payload)`.
9. The scheduler deletes the `cron_jobs` row for the fired job.

## Alternate Flows
### A1: Subscriber Already Listening
Condition: A LiveView or process is subscribed to `"agent:#{agent_id}:scheduled"` before the timer fires.
Steps:
1. When the broadcast occurs in step 8, the subscriber receives the payload immediately.
2. No additional steps are needed; PubSub delivery is synchronous from the broadcaster's perspective.

## Failure Flows
### F1: Negative or Zero delay_ms
Condition: `delay_ms` is zero or negative.
Steps:
1. The CronScheduler detects `delay_ms <= 0` in the guard.
2. It returns `{:error, :invalid_delay}` without registering a timer or writing to `cron_jobs`.
Result: No timer is registered; no database row is written; the caller receives `{:error, :invalid_delay}`.

### F2: CronScheduler Crashes Before Timer Fires
Condition: The GenServer process crashes after writing the `cron_jobs` row but before the timer fires.
Steps:
1. The in-memory timer reference is lost with the process.
2. On restart, the GenServer `init/1` reads all `cron_jobs` rows and re-schedules them.
3. If `next_fire_at` is in the past, the job is fired immediately in the first poll cycle.
Result: The job fires at most once more after restart; no silent job loss occurs.

## Gherkin Scenarios

### S1: Valid schedule_once broadcasts payload after delay
```gherkin
Scenario: schedule_once with valid delay broadcasts payload
  Given the CronScheduler GenServer is running
  And no subscriber exists on "agent:agent-7:scheduled"
  When CronScheduler.schedule_once("agent-7", 5000, %{reminder: "check_quota"}) is called
  Then the return value is :ok
  And a row exists in cron_jobs with agent_id "agent-7" and is_one_time true
  And after 5000 milliseconds the payload %{reminder: "check_quota"} is broadcast on "agent:agent-7:scheduled"
  And the cron_jobs row for "agent-7" is deleted after the broadcast
```

### S2: Negative delay_ms returns error tuple
```gherkin
Scenario: schedule_once with negative delay returns {:error, :invalid_delay}
  Given the CronScheduler GenServer is running
  When CronScheduler.schedule_once("agent-7", -1, %{reminder: "check_quota"}) is called
  Then the return value is {:error, :invalid_delay}
  And no row is inserted into cron_jobs
```

## Acceptance Criteria
- [ ] `mix test test/observatory/gateway/cron_scheduler_test.exs` passes a test that `schedule_once/3` with a positive `delay_ms` returns `:ok`, inserts a `cron_jobs` row with `is_one_time: true`, and eventually broadcasts the payload on `"agent:{agent_id}:scheduled"`.
- [ ] `mix test test/observatory/gateway/cron_scheduler_test.exs` passes a test that `schedule_once/3` with `delay_ms: -1` returns `{:error, :invalid_delay}` and inserts no `cron_jobs` row.
- [ ] `mix compile --warnings-as-errors` passes.

## Data
**Inputs:** `agent_id` (string), `delay_ms` (positive integer), `payload` (map)
**Outputs:** `:ok` or `{:error, :invalid_delay}`; PubSub broadcast of `payload` after delay
**State changes:** `cron_jobs` row inserted on call; deleted after job fires.

## Traceability
- Parent FR: FR-10.5
- ADR: [ADR-019](../../decisions/ADR-019-heartbeat-leader-election.md)
