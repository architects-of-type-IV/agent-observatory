---
id: FRD-003
title: Messaging Pipeline Functional Requirements
date: 2026-02-21
status: draft
source_adr: [ADR-004, ADR-005]
related_rule: []
---

# FRD-003: Messaging Pipeline

## Purpose

The messaging pipeline is the subsystem responsible for delivering messages between the Observatory Dashboard and Claude Code agents running in swarm sessions. It provides two complementary delivery channels: an in-memory ETS store (`:observatory_mailboxes`) managed by the `Observatory.Mailbox` GenServer, and a filesystem command queue managed by the `Observatory.CommandQueue` GenServer that writes JSON files to `~/.claude/inbox/{session_id}/`. Together these channels give agents a reliable polling surface while giving the dashboard real-time delivery via Phoenix PubSub.

The design was shaped by two architectural decisions. ADR-004 identified that the dashboard and agents were using incompatible delivery paths — custom Observatory inbox files vs. Claude Code native team inbox files — and unified all four message-sending forms through `Mailbox.send_message/4` as an immediate fix, with a staged migration to native Claude Code team messaging paths planned as follow-up work. ADR-005 chose ETS over a database-backed Ash resource because agent messages are inherently transient coordination signals whose value expires when a swarm session ends; the overhead of migrations and database queries is not justified for this workload.

## Functional Requirements

### FR-3.1: Single Entry Point for All Message Sends

All outbound messages from the dashboard MUST be routed through `Observatory.Mailbox.send_message/4`. No dashboard code path MAY call `Observatory.CommandQueue.write_command/2` or `Phoenix.PubSub.broadcast/3` directly for message delivery. The four dashboard message forms — `send_targeted_message`, `send_agent_message`, `send_team_broadcast`, and `send_command_message` — MUST each invoke `Observatory.Mailbox.send_message/4` (or `Observatory.Mailbox.broadcast_to_many/4` for team broadcasts) as their sole delivery mechanism.

**Positive path**: A call to `Mailbox.send_message(to, from, content, opts)` atomically performs three side effects — inserts the message into ETS, writes a JSON file to `~/.claude/inbox/{to}/`, and broadcasts a `{:new_mailbox_message, message}` event on the `"agent:#{to}"` PubSub topic — and returns `{:ok, message}`.

**Negative path**: If any dashboard event handler calls `CommandQueue.write_command/2` or `PubSub.broadcast/3` directly for message delivery, the three channels fall out of sync: ETS may be missing the message (preventing `unread_count/1` from reflecting it), the filesystem file may be missing (preventing MCP polling from delivering it), or PubSub may not fire (preventing the dashboard from updating in real time). Partial delivery is indistinguishable from no delivery from the agent's perspective.

---

### FR-3.2: ETS Table Structure and Message Record Shape

The `Observatory.Mailbox` GenServer MUST own a named ETS table called `:observatory_mailboxes` with options `[:named_table, :public, :set]`. Each entry in the table MUST have the key `agent_id` (a string) and the value `[messages]` (a list of message maps). Each message map MUST contain the following fields:

- `id` — a 16-character lowercase hex string generated by `Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)`
- `from` — the sender's session ID string (e.g., `"dashboard"`)
- `to` — the recipient's session ID string
- `content` — the message body string
- `type` — an atom defaulting to `:text`; MAY be `:context_push` or any atom provided in the `opts` keyword list under the `:type` key
- `timestamp` — a `DateTime` value set to `DateTime.utc_now()` at insertion time
- `read` — a boolean, initially `false`
- `metadata` — a map defaulting to `%{}`; MAY contain arbitrary key-value pairs provided via `opts[:metadata]`

**Positive path**: After `Mailbox.send_message("agent-42", "dashboard", "hello", type: :text)`, `:ets.lookup(:observatory_mailboxes, "agent-42")` returns `[{"agent-42", [%{id: _, from: "dashboard", to: "agent-42", content: "hello", type: :text, timestamp: _, read: false, metadata: %{}}]}]`.

**Negative path**: If a message is stored without the `read` field set to `false`, the cleanup job (`FR-3.8`) cannot distinguish read messages from unread ones and MAY incorrectly expire messages that have not yet been delivered. If the `timestamp` field is absent or not a `DateTime`, `Mailbox.get_stats/0` will crash when computing `DateTime.diff/3`.

---

### FR-3.3: Dual-Write — ETS and Filesystem

For every call to `Mailbox.send_message/4`, the Mailbox GenServer MUST write to both the ETS table and the filesystem via `Observatory.CommandQueue.write_command/2` before returning. The ETS write MUST prepend the new message to the existing list for the recipient (i.e., messages are stored newest-first). The CommandQueue write MUST produce a JSON file at `~/.claude/inbox/{session_id}/{id}.json` containing the fields `type`, `from`, `content`, `message_type`, `metadata`, `id`, `session_id`, and `timestamp` (ISO 8601 string).

**Positive path**: After `Mailbox.send_message("abc", "dashboard", "go")`, both `:ets.lookup(:observatory_mailboxes, "abc")` and `File.ls!(Path.expand("~/.claude/inbox/abc/"))` reflect the message. An agent polling via MCP `check_inbox` will find the file; a LiveView subscribed to `"agent:abc"` will receive the PubSub event.

**Negative path**: If the `CommandQueue.write_command/2` call fails silently (e.g., filesystem permission error), ETS and PubSub still deliver, but the agent's MCP polling path sees no message. The agent will not act on the message. On Phoenix restart, ETS is cleared and the CommandQueue file — if it were present — would serve as a replay source; without the file, the message is permanently lost after restart.

---

### FR-3.4: Team Agent Dual-Write — Claude Code Native Inbox

When the recipient `to` parameter contains an `@` character (format: `"agent_name@team_name"`), `Mailbox.send_message/4` MUST additionally call `Observatory.CommandQueue.write_team_message/3` to write the message in Claude Code native format to `~/.claude/teams/{team_name}/inboxes/{agent_name}.json`. The native format entry MUST be a JSON object with the fields `"from"`, `"text"`, `"timestamp"` (ISO 8601), and `"read": false`. Native inbox files MUST be JSON arrays, with new messages appended to the end of the existing array.

**Positive path**: `Mailbox.send_message("worker@my-team", "dashboard", "task done")` results in both a file at `~/.claude/inbox/worker@my-team/{id}.json` (custom format) and an appended entry in `~/.claude/teams/my-team/inboxes/worker.json` (native format). The agent receives the message through whichever polling mechanism it uses.

**Negative path**: If the `@` parsing is omitted, agents using Claude Code's native SendMessage / team inbox polling will never receive dashboard messages. The split between custom and native inbox paths was the original bug described in ADR-004; skipping the team write re-introduces that split.

---

### FR-3.5: PubSub Broadcast on Every Send

After each successful ETS insert, `Mailbox.send_message/4` MUST broadcast a `{:new_mailbox_message, message}` event on the topic `"agent:#{to}"` via `Phoenix.PubSub.broadcast(Observatory.PubSub, "agent:#{to}", {:new_mailbox_message, message})`. The message map included in the broadcast payload MUST be the same map stored in ETS, including all required fields from FR-3.2.

**Positive path**: Any LiveView or process subscribed to `"agent:dashboard"` receives `{:new_mailbox_message, message}` within the same GenServer call that inserted to ETS. The dashboard's `handle_info({:new_mailbox_message, message}, socket)` clause fires and refreshes unread counts.

**Negative path**: If PubSub broadcast is skipped or fires with an incomplete message map, the dashboard does not update in real time. The operator must manually refresh to see incoming agent messages. This was the exact failure mode that ADR-004 remedied — the dashboard was not subscribed to `"agent:dashboard"` and messages accumulated silently in ETS.

---

### FR-3.6: Dashboard Subscription to the Agent Inbox Topic

The `ObservatoryWeb.DashboardLive` module MUST subscribe to the PubSub topic `"agent:dashboard"` during `mount/3` when `connected?(socket)` is true. The dashboard MUST also assign `current_session_id: "dashboard"` to the socket at mount time so that outbound messages are attributed to `"dashboard"` as the sender. The dashboard MUST handle the `{:new_mailbox_message, message}` info message and refresh mailbox state in response.

**Positive path**: On mount, the dashboard subscribes to `"agent:dashboard"`. When an agent calls the MCP `send_message` tool targeting `"dashboard"`, `Mailbox.send_message("dashboard", agent_sid, content)` fires, which broadcasts `{:new_mailbox_message, msg}` on `"agent:dashboard"`. The dashboard's `handle_info` clause calls `handle_new_mailbox_message/2`, which invokes `refresh_mailbox_assigns/1` to recompute unread counts.

**Negative path**: If the dashboard does not subscribe to `"agent:dashboard"` at mount, agent replies arrive in ETS but the dashboard never re-renders. The operator sees no visual indication of new messages until the next full page load. This was the second half of the bug corrected by ADR-004.

---

### FR-3.7: Per-Session Mailbox Subscriptions

During `mount/3`, `ObservatoryWeb.DashboardLive` MUST call `subscribe_to_mailboxes/1` with the list of active sessions derived from recent events. `subscribe_to_mailboxes/1` MUST call `Observatory.Channels.subscribe_agent/1` for each session, ensuring the dashboard receives `{:new_mailbox_message, _}` events for all active agent sessions, not only the `"dashboard"` topic.

**Positive path**: A session derived from the event feed — e.g., `session_id: "abc123"` — has its `"agent:abc123"` topic subscribed at mount. When the dashboard sends a message to that agent and the agent replies, the reply PubSub event reaches the dashboard even though the topic differs from `"agent:dashboard"`.

**Negative path**: Without per-session subscriptions, only messages addressed to `"dashboard"` trigger real-time UI updates. Messages that agents send to their own session topic, or cross-agent messages brokered through the dashboard, go unnoticed until the next page load.

---

### FR-3.8: ETS Cleanup — 24-Hour TTL for Read Messages

The `Observatory.Mailbox` GenServer MUST schedule a periodic cleanup via `Process.send_after(self(), :cleanup_old_messages, 60_000)` that fires every 60 seconds. During cleanup, the GenServer MUST remove any message from every agent mailbox that satisfies BOTH conditions: `msg.read == true` AND `DateTime.diff(DateTime.utc_now(), msg.timestamp, :hour) > 24`. Unread messages MUST NOT be removed regardless of age.

**Positive path**: After 24 hours, a message that an agent has acknowledged (marked `:read = true` via `Mailbox.mark_read/2`) is pruned from ETS. Long-running Observatory instances do not accumulate unbounded ETS memory during normal operation.

**Negative path**: If the cleanup timer is not rescheduled after each firing (i.e., `schedule_cleanup/0` is not called at the end of `handle_info(:cleanup_old_messages, state)`), cleanup runs exactly once after startup and then stops. ETS grows without bound. If cleanup erroneously removes unread messages, agents attempting to `check_inbox` via MCP will find their messages gone before they can acknowledge them.

---

### FR-3.9: CommandQueue Outbox Polling

The `Observatory.CommandQueue` GenServer MUST poll `~/.claude/outbox/{session_id}/` directories every 2000 milliseconds for JSON response files written by agents. For each file found, the GenServer MUST read and JSON-decode the file, broadcast the decoded map on the PubSub topic `"session:#{session_id}"` as `{:command_responses, [decoded_map, ...]}`, and delete the file after successful decoding. Files that fail JSON decoding MUST be logged at error level and left in place (not deleted).

**Positive path**: An agent writes `~/.claude/outbox/abc123/resp-001.json`. Within 2 seconds, `CommandQueue` reads the file, broadcasts `{:command_responses, [%{...}]}` on `"session:abc123"`, and deletes the file. No polling accumulation occurs under normal operation.

**Negative path**: If files are deleted before decoding, a malformed JSON file causes permanent data loss with no opportunity for operator inspection. If the poll interval is not rescheduled after each firing via `schedule_poll/0` at the end of `handle_info(:poll_outbox, state)`, outbox polling stops after the first interval.

---

### FR-3.10: CommandQueue Filesystem Initialization

The `Observatory.CommandQueue` GenServer MUST call `File.mkdir_p!/1` for both `~/.claude/inbox/` (expanded from `Path.expand("~/.claude/inbox")`) and `~/.claude/outbox/` (expanded from `Path.expand("~/.claude/outbox")`) during `init/1`. These directories MUST exist before any `write_command/2` or outbox polling occurs.

**Positive path**: On startup, both directories are created if absent. A subsequent `write_command("new-agent", %{type: "message", ...})` succeeds without a `File.mkdir_p!` call at the callsite, because the session subdirectory is created per-call in `do_write_command/2`.

**Negative path**: If `ensure_directories/0` is not called during init, the first `write_command/2` for a new session will fail because the parent `~/.claude/inbox/` directory does not exist, causing the agent's first message to be dropped silently from the filesystem channel (though ETS and PubSub delivery still proceed).

---

### FR-3.11: Mailbox Statistics API

`Observatory.Mailbox.get_stats/0` MUST return a list of maps, one per agent_id present in `:observatory_mailboxes`, each containing the fields `agent_id` (string), `total` (non-negative integer — total messages in mailbox), `unread` (non-negative integer — count of messages where `read == false`), and `oldest_unread_age_sec` (non-negative integer — seconds since the oldest unread message's `timestamp`; `0` if no unread messages exist). This function MUST read directly from ETS via `:ets.tab2list/1` without going through the GenServer.

**Positive path**: `Mailbox.get_stats()` returns `[%{agent_id: "abc", total: 5, unread: 2, oldest_unread_age_sec: 142}]`. The SwarmMonitor or dashboard can display per-agent mailbox health without holding the GenServer lock.

**Negative path**: If `get_stats/0` routes through the GenServer instead of reading ETS directly, it serializes with all other Mailbox operations. Under high message volume, stat queries could delay message delivery.

---

### FR-3.12: CommandQueue Statistics API

`Observatory.CommandQueue.get_queue_stats/0` MUST return a list of maps for all session directories under `~/.claude/inbox/` that have at least one `.json` file present. Each map MUST contain `session_id` (string), `pending_count` (non-negative integer — count of `.json` files in the session subdirectory), and `oldest_age_sec` (non-negative integer — seconds since the oldest file's mtime; `0` if no files). Sessions with `pending_count == 0` MUST be excluded from the result.

**Positive path**: After 10 messages are written for `"agent-x"` and none are acknowledged, `CommandQueue.get_queue_stats()` returns `[%{session_id: "agent-x", pending_count: 10, oldest_age_sec: _}]`. An operator can detect stale CommandQueue accumulation indicative of a dead agent.

**Negative path**: If sessions with `pending_count == 0` are included in the result, the stats API returns noise for every session that has ever received a message, making it impossible to identify agents with unprocessed queues.

---

### FR-3.13: Broadcast to Multiple Recipients

`Observatory.Mailbox.broadcast_to_many/4` MUST accept a list of session ID strings and invoke `send_message/4` once per entry in the list, passing the same `from`, `content`, and `opts` to each. It MUST return a list of `{:ok, message} | {:error, reason}` in the same order as the input session IDs.

**Positive path**: `Mailbox.broadcast_to_many(["a", "b", "c"], "dashboard", "start", [])` results in three ETS entries, three CommandQueue files, and three PubSub broadcasts — one per recipient. Each team member receives an independent copy of the message.

**Negative path**: If `broadcast_to_many/4` is implemented as a single PubSub broadcast to a shared topic instead of individual `send_message/4` calls per recipient, CommandQueue files are not written, and agents that poll via MCP will not receive the broadcast.

---

## Out of Scope (Phase 1)

- Full migration to Claude Code native messaging paths as the sole delivery channel (the `~/.claude/teams/{team}/inboxes/{agent}.json` format); custom CommandQueue inbox files (`~/.claude/inbox/`) remain active during the migration period described in ADR-004.
- Message ordering guarantees across ETS, CommandQueue, and PubSub channels.
- Database-backed message persistence (rejected in ADR-005 as overkill for transient coordination messages).
- Deduplication logic to prevent duplicate delivery after Phoenix restart (ETS cleared, CommandQueue files replayed).
- Cleanup of accumulated stale CommandQueue files from prior sessions (164 stale files noted as known debt in ADR-004).
- Per-message delivery receipts or acknowledgement feedback to the sender.

## Related ADRs

- [ADR-004](../../decisions/ADR-004-messaging-architecture.md) -- Established unified routing through `Mailbox.send_message/4`, dashboard subscription to `"agent:dashboard"`, and `current_session_id: "dashboard"` as the immediate fix; described staged migration to native Claude Code messaging paths.
- [ADR-005](../../decisions/ADR-005-ets-over-database.md) -- Chose ETS + CommandQueue filesystem over Ash resource + Postgres; accepted trade-offs of ephemerality, no ordering guarantees, and unbounded growth mitigated by 24h cleanup.
